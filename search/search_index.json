{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FastAPI Health","text":"<p>The goal of this package is to help you to implement the Health Check API pattern.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fastapi-health\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The easier way to use this package is to use the <code>health</code> function.</p> <p>Create the health check endpoint dynamically using different conditions. Each condition is a callable, and you can even have dependencies inside of it:</p> PostgreSQLRedisMongoDB <pre><code>import asyncio\nfrom fastapi import FastAPI, Depends\nfrom fastapi_health import health\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.ext.asyncio import AsyncSession\n# You need to implement yourself \ud83d\udc47\nfrom app.database import get_session\nasync def is_database_online(session: AsyncSession = Depends(get_session)):\ntry:\nawait asyncio.wait_for(session.execute(\"SELECT 1\"), timeout=30)\nexcept (SQLAlchemyError, TimeoutError):\nreturn False\nreturn True\napp = FastAPI()\napp.add_api_route(\"/health\", health([is_database_online]))\n</code></pre> <pre><code>import asyncio\nfrom fastapi import FastAPI, Depends\nfrom fastapi_health import health\nfrom redis import ConnectionError\nfrom redis.asyncio import Redis\n# You need to implement yourself \ud83d\udc47\nfrom app.redis import get_redis\nasync def is_redis_alive(client: Redis = Depends(get_redis)):\ntry:\nawait asyncio.wait_for(client.check_health(), timeout=30)\nexcept (ConnectionError, RuntimeError, TimeoutError):\nreturn False\nreturn True\napp = FastAPI()\napp.add_api_route(\"/health\", health([is_redis_alive]))\n</code></pre> <pre><code>import asyncio\nfrom fastapi import FastAPI, Depends\nfrom fastapi_health import health\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom pymongo.errors import ServerSelectionTimeoutError\n# You need to implement yourself \ud83d\udc47\nfrom app.mongodb import get_mongo\nasync def is_mongo_alive(client: AsyncIOMotorClient = Depends(get_mongo)):\ntry:\nawait asyncio.wait_for(client.server_info(), timeout=30)\nexcept (ServerSelectionTimeoutError, TimeoutError):\nreturn False\nreturn True\napp = FastAPI()\napp.add_api_route(\"/health\", health([is_mongo_alive]))\n</code></pre> <p>You can check the API reference for more details.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#fastapi_health.route.health","title":"<code>health(conditions, *, success_handler=default_handler, failure_handler=default_handler, success_status=200, failure_status=503)</code>","text":"<p>Create a health check route.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>List[Callable[..., Dict[str, Any] | bool]]</code> <p>A list of callables that represents the condition of your service.</p> required <code>success_handler</code> <code>Callable[..., Awaitable[dict]]</code> <p>A callable which receives the <code>conditions</code> results, and returns a dictionary that will be the content response of a successful health call.</p> <code>default_handler</code> <code>failure_handler</code> <code>Callable[..., Awaitable[dict]]</code> <p>A callable analogous to <code>success_handler</code> for failure scenarios.</p> <code>default_handler</code> <code>success_status</code> <code>int</code> <p>An integer that overwrites the default status (<code>200</code>) in case of success.</p> <code>200</code> <code>failure_status</code> <code>int</code> <p>An integer that overwrites the default status (<code>503</code>) in case of failure.</p> <code>503</code> <p>Returns:</p> Type Description <code>Callable[..., Coroutine[None, None, JSONResponse]]</code> <p>Callable[..., Awaitable[JSONResponse]]: The health check route.</p> Source code in <code>fastapi_health/route.py</code> <pre><code>def health(\nconditions: List[ConditionFunc],\n*,\nsuccess_handler: Callable[..., Awaitable[dict]] = default_handler,\nfailure_handler: Callable[..., Awaitable[dict]] = default_handler,\nsuccess_status: int = 200,\nfailure_status: int = 503,\n) -&gt; Callable[..., Coroutine[None, None, JSONResponse]]:\n\"\"\"Create a health check route.\n    Args:\n        conditions (List[Callable[..., Dict[str, Any] | bool]]): A list of callables\n            that represents the condition of your service.\n        success_handler (Callable[..., Awaitable[dict]]): A callable which receives\n            the `conditions` results, and returns a dictionary that will be the content\n            response of a successful health call.\n        failure_handler (Callable[..., Awaitable[dict]]): A callable analogous to\n            `success_handler` for failure scenarios.\n        success_status (int): An integer that overwrites the default status (`200`) in\n            case of success.\n        failure_status (int): An integer that overwrites the default status (`503`) in\n            case of failure.\n    Returns:\n        Callable[..., Awaitable[JSONResponse]]: The health check route.\n    \"\"\"\nasync def endpoint(**dependencies) -&gt; JSONResponse:\nif all(dependencies.values()):\nhandler = success_handler\nstatus_code = success_status\nelse:\nhandler = failure_handler\nstatus_code = failure_status\noutput = await handler(**dependencies)\nreturn JSONResponse(jsonable_encoder(output), status_code=status_code)\nparams = []\nfor condition in conditions:\nparams.append(\nParameter(\nf\"{condition.__name__}\",\nkind=Parameter.POSITIONAL_OR_KEYWORD,\nannotation=bool,\ndefault=Depends(condition),\n)\n)\nendpoint.__signature__ = Signature(params)\nreturn endpoint\n</code></pre>"}]}